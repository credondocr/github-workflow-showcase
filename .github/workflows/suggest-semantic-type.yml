name: Suggest Semantic Type

on:
  pull_request:
    types: [opened]
    branches: [ main, develop ]

jobs:
  suggest-type:
    name: ğŸ’¡ Suggest Semantic Type
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: ğŸ” Analyze changes and suggest type
        uses: actions/github-script@v7
        with:
          script: |
            const prTitle = context.payload.pull_request.title;
            const prBody = context.payload.pull_request.body || '';
            
            // Check if title already follows semantic format
            const semanticRegex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .+/;
            
            if (semanticRegex.test(prTitle)) {
              console.log('âœ… Title already follows semantic format');
              return;
            }
            
            console.log(`ğŸ” Analyzing non-semantic title: "${prTitle}"`);
            
            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_request_number: context.issue.number
            });
            
            const changedFiles = files.map(file => file.filename);
            const additions = files.reduce((sum, file) => sum + file.additions, 0);
            const deletions = files.reduce((sum, file) => sum + file.deletions, 0);
            
            console.log(`ğŸ“ Files changed: ${changedFiles.length}`);
            console.log(`â• Lines added: ${additions}`);
            console.log(`â– Lines deleted: ${deletions}`);
            
            // Analyze content for type detection
            const titleLower = prTitle.toLowerCase();
            const bodyLower = prBody.toLowerCase();
            const content = `${titleLower} ${bodyLower}`;
            
            // Suggested types based on analysis
            const suggestions = [];
            let primarySuggestion = '';
            let confidence = 0;
            
            // File-based analysis
            const fileAnalysis = {
              docs: changedFiles.some(f => /\.(md|txt|rst|doc)$/i.test(f)),
              tests: changedFiles.some(f => /(_test\.go|^tests\/)/.test(f)),
              ci: changedFiles.some(f => /^\.github\//.test(f)),
              build: changedFiles.some(f => /^(go\.(mod|sum)|Dockerfile|docker-compose|Makefile)$/i.test(f)),
              config: changedFiles.some(f => /\.(yml|yaml|json|toml|ini|conf)$/i.test(f)),
              core: changedFiles.some(f => /^main\.go$/.test(f)),
              models: changedFiles.some(f => /^models\//.test(f)),
              controllers: changedFiles.some(f => /^controllers\//.test(f)),
              routes: changedFiles.some(f => /^routes\//.test(f))
            };
            
            // Content-based analysis patterns
            const contentPatterns = {
              feat: [
                /\b(add|implement|introduce|create|new)\b/,
                /\b(feature|functionality|capability)\b/,
                /\b(support for|enable)\b/
              ],
              fix: [
                /\b(fix|resolve|correct|patch|bug)\b/,
                /\b(issue|problem|error|exception)\b/,
                /\b(handle|prevent|avoid)\b/
              ],
              docs: [
                /\b(document|readme|guide|manual)\b/,
                /\b(explain|describe|clarify)\b/,
                /\b(example|tutorial|instruction)\b/
              ],
              refactor: [
                /\b(refactor|restructure|reorganize|cleanup)\b/,
                /\b(simplify|improve|optimize)(?!.*performance)\b/,
                /\b(extract|consolidate|modularize)\b/
              ],
              perf: [
                /\b(optimize|performance|speed|fast)\b/,
                /\b(cache|memory|cpu|latency)\b/,
                /\b(efficient|benchmark)\b/
              ],
              style: [
                /\b(format|formatting|style|lint)\b/,
                /\b(whitespace|indentation|prettier)\b/,
                /\b(gofmt|eslint|prettier)\b/
              ],
              test: [
                /\b(test|testing|spec|coverage)\b/,
                /\b(unit|integration|e2e)\b/,
                /\b(mock|stub|fixture)\b/
              ],
              chore: [
                /\b(update|upgrade|bump|maintenance)\b/,
                /\b(clean|cleanup|remove|delete)\b/,
                /\b(config|configuration|setup)\b/
              ]
            };
            
            // Calculate confidence scores
            const scores = {};
            
            // File-based scoring (high confidence)
            if (fileAnalysis.docs && !fileAnalysis.tests && !fileAnalysis.ci) {
              scores.docs = 90;
            }
            if (fileAnalysis.tests && changedFiles.every(f => /(_test\.go|^tests\/)/.test(f))) {
              scores.test = 85;
            }
            if (fileAnalysis.ci) {
              scores.ci = 85;
            }
            if (fileAnalysis.build) {
              scores.build = 80;
            }
            
            // Content-based scoring (medium confidence)
            for (const [type, patterns] of Object.entries(contentPatterns)) {
              const matches = patterns.filter(pattern => pattern.test(content)).length;
              if (matches > 0) {
                scores[type] = (scores[type] || 0) + (matches * 20);
              }
            }
            
            // Special logic for different scenarios
            if (deletions > additions * 2 && deletions > 20) {
              scores.refactor = (scores.refactor || 0) + 30;
              scores.chore = (scores.chore || 0) + 20;
            }
            
            if (additions > 100 && fileAnalysis.models && fileAnalysis.controllers) {
              scores.feat = (scores.feat || 0) + 40;
            }
            
            if (content.includes('bug') || content.includes('issue') || content.includes('problem')) {
              scores.fix = (scores.fix || 0) + 50;
            }
            
            // Sort by confidence score
            const sortedScores = Object.entries(scores).sort(([,a], [,b]) => b - a);
            
            if (sortedScores.length > 0) {
              primarySuggestion = sortedScores[0][0];
              confidence = sortedScores[0][1];
            }
            
            // Generate suggestions based on analysis
            if (confidence >= 60) {
              suggestions.push({
                type: primarySuggestion,
                title: `${primarySuggestion}: ${prTitle}`,
                confidence: confidence,
                reason: getReasonForSuggestion(primarySuggestion, fileAnalysis, content)
              });
            }
            
            // Add top 2-3 alternatives
            for (let i = 1; i < Math.min(3, sortedScores.length); i++) {
              if (sortedScores[i][1] >= 30) {
                suggestions.push({
                  type: sortedScores[i][0],
                  title: `${sortedScores[i][0]}: ${prTitle}`,
                  confidence: sortedScores[i][1],
                  reason: getReasonForSuggestion(sortedScores[i][0], fileAnalysis, content)
                });
              }
            }
            
            // Always provide some fallback suggestions
            if (suggestions.length === 0) {
              suggestions.push(
                { type: 'feat', title: `feat: ${prTitle}`, confidence: 20, reason: 'Default for new functionality' },
                { type: 'fix', title: `fix: ${prTitle}`, confidence: 20, reason: 'If this solves a problem' },
                { type: 'chore', title: `chore: ${prTitle}`, confidence: 20, reason: 'For maintenance tasks' }
              );
            }
            
            function getReasonForSuggestion(type, fileAnalysis, content) {
              const reasons = {
                feat: 'New functionality detected',
                fix: 'Bug fix patterns detected',
                docs: 'Documentation files modified',
                test: 'Test files modified',
                ci: 'CI/CD files modified',
                build: 'Build/dependency files modified',
                refactor: 'Code restructuring detected',
                perf: 'Performance optimization detected',
                style: 'Code formatting detected',
                chore: 'Maintenance task detected'
              };
              return reasons[type] || 'Based on content analysis';
            }
            
            // Create helpful comment
            if (suggestions.length > 0) {
              const suggestionList = suggestions.map((s, i) => 
                `${i + 1}. \`${s.title}\` ${s.confidence >= 60 ? 'â­' : ''}
                   - **Reason:** ${s.reason}
                   - **Confidence:** ${s.confidence}%`
              ).join('\n\n');
              
              const helpComment = `## ğŸ’¡ Semantic Title Suggestions
              
              Your PR title doesn't follow the semantic format yet. Based on the files you've changed and the content, here are some suggestions:
              
              ${suggestionList}
              
              ### ğŸ“‹ Why Semantic Titles?
              - ğŸ¤– **Automated changelogs** - Generate release notes automatically
              - ğŸ·ï¸ **Better organization** - Automatic labeling and categorization  
              - ğŸ” **Easier review** - Reviewers understand the change type immediately
              - ğŸ“Š **Project insights** - Track development patterns over time
              
              ### ğŸ¯ Quick Format Guide:
              \`\`\`
              <type>: <description>
              \`\`\`
              
              **Common types:** \`feat\`, \`fix\`, \`docs\`, \`refactor\`, \`test\`, \`chore\`
              
              ### ğŸ”§ Next Steps:
              1. Pick one of the suggestions above
              2. Edit your PR title 
              3. The validation will run automatically
              
              ğŸ“š [Full semantic guide](./.github/SEMANTIC_PR_GUIDE.md) | âš™ï¸ This analysis is based on file changes and content patterns
              
              ---
              *This suggestion will disappear once you update to a semantic title* âœ¨`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: helpComment
              });
              
              console.log(`ğŸ’¡ Added suggestion comment with ${suggestions.length} options`);
              console.log(`ğŸ¯ Primary suggestion: ${primarySuggestion} (${confidence}% confidence)`);
            }

      - name: âœ… Suggestion complete
        run: |
          echo "ğŸ’¡ Semantic type suggestion completed"
          echo "ğŸ” Analyzed PR content and file changes"
          echo "ğŸ’¬ Posted helpful suggestions if needed"
