name: PR Type Detection

on:
  pull_request:
    types: [opened, edited, synchronize]
    branches: [ main, develop ]

jobs:
  detect-pr-type:
    name: ğŸ” Detect PR Type
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: ğŸ” Analyze PR content
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            // Get PR details
            const prTitle = context.payload.pull_request.title.toLowerCase();
            const prBody = (context.payload.pull_request.body || '').toLowerCase();
            const prContent = `${prTitle} ${prBody}`;
            
            console.log(`Analyzing PR: "${context.payload.pull_request.title}"`);
            
            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_request_number: context.issue.number
            });
            
            const changedFiles = files.map(file => file.filename);
            const additions = files.reduce((sum, file) => sum + file.additions, 0);
            const deletions = files.reduce((sum, file) => sum + file.deletions, 0);
            
            console.log(`Files changed: ${changedFiles.length}`);
            console.log(`Additions: ${additions}, Deletions: ${deletions}`);
            
            // Type detection patterns
            const typePatterns = {
              'type: feature': [
                // Title patterns
                /^(feat|feature|add)/i,
                /implement/i,
                /introduce/i,
                /new\s+/i,
                // Content patterns
                /new feature/i,
                /implement.*feature/i,
                /add.*functionality/i,
                /introduce.*capability/i
              ],
              'type: bugfix': [
                // Title patterns
                /^(fix|bug|hotfix)/i,
                /resolve/i,
                /correct/i,
                // Content patterns
                /fix.*bug/i,
                /resolve.*issue/i,
                /fix.*error/i,
                /bug.*fix/i,
                /closes #\d+/i,
                /fixes #\d+/i
              ],
              'type: enhancement': [
                // Title patterns
                /^(improve|enhance|update|upgrade)/i,
                /better/i,
                /optimize(?!.*performance)/i,
                // Content patterns
                /improve.*performance/i,
                /enhance.*functionality/i,
                /better.*experience/i,
                /upgrade.*to/i
              ],
              'type: refactor': [
                // Title patterns
                /^refactor/i,
                /cleanup/i,
                /restructure/i,
                /reorganize/i,
                // Content patterns
                /code.*refactor/i,
                /clean.*up/i,
                /restructure.*code/i,
                /no.*functional.*change/i
              ],
              'type: performance': [
                // Title patterns
                /^perf/i,
                /performance/i,
                /optimize.*performance/i,
                /speed.*up/i,
                // Content patterns
                /improve.*performance/i,
                /optimize.*speed/i,
                /reduce.*latency/i,
                /faster.*execution/i
              ],
              'type: security': [
                // Title patterns
                /^security/i,
                /^sec/i,
                /vulnerability/i,
                /secure/i,
                // Content patterns
                /security.*fix/i,
                /vulnerability.*patch/i,
                /security.*update/i,
                /fix.*security/i
              ],
              'type: breaking': [
                // Title patterns
                /^breaking/i,
                /breaking.*change/i,
                // Content patterns
                /breaking.*change/i,
                /breaking.*api/i,
                /api.*breaking/i,
                /major.*change/i
              ]
            };
            
            // Special detection based on file patterns
            const filePatterns = {
              'area: tests': /(_test\.go|^tests\/)/,
              'area: ci/cd': /^\.github\//,
              'area: documentation': /\.(md|txt|rst)$/,
              'area: dependencies': /^(go\.(mod|sum)|package\.json|requirements\.txt)/,
              'area: docker': /^(Dockerfile|\.dockerignore|docker-compose)/,
              'area: configuration': /\.(yml|yaml|json|toml|ini|conf)$/
            };
            
            // Detect types
            const detectedTypes = [];
            
            for (const [type, patterns] of Object.entries(typePatterns)) {
              const matches = patterns.some(pattern => pattern.test(prContent));
              if (matches) {
                detectedTypes.push(type);
                console.log(`âœ… Detected type: ${type}`);
              }
            }
            
            // Special logic for breaking changes
            if (deletions > additions * 2 && deletions > 50) {
              detectedTypes.push('type: breaking');
              console.log(`âœ… Detected breaking change based on deletion ratio`);
            }
            
            // Check if only test files changed
            const onlyTestFiles = changedFiles.length > 0 && 
              changedFiles.every(file => /(_test\.go|^tests\/)/.test(file));
            
            if (onlyTestFiles) {
              detectedTypes.push('area: tests');
              if (!detectedTypes.some(t => t.startsWith('type:'))) {
                detectedTypes.push('type: enhancement');
              }
            }
            
            // Detect file-based areas
            for (const [areaType, pattern] of Object.entries(filePatterns)) {
              if (changedFiles.some(file => pattern.test(file))) {
                detectedTypes.push(areaType);
                console.log(`âœ… Detected area: ${areaType}`);
              }
            }
            
            // If no type detected, try to infer from title patterns
            if (!detectedTypes.some(t => t.startsWith('type:'))) {
              if (/^(chore|misc|other)/i.test(prTitle)) {
                detectedTypes.push('type: enhancement');
              } else if (changedFiles.some(f => f.includes('test'))) {
                detectedTypes.push('type: enhancement');
              } else {
                detectedTypes.push('type: feature'); // Default fallback
              }
            }
            
            // Ensure labels exist and add them
            const labelsToAdd = [...new Set(detectedTypes)]; // Remove duplicates
            
            for (const label of labelsToAdd) {
              // Try to create label if it doesn't exist
              const labelConfigs = {
                'type: feature': { color: '84B6EB', description: 'New feature implementation' },
                'type: bugfix': { color: 'D73A4A', description: 'Bug fix or error correction' },
                'type: enhancement': { color: 'A2EEEF', description: 'Improvement to existing functionality' },
                'type: refactor': { color: '7057FF', description: 'Code refactoring without functional changes' },
                'type: performance': { color: 'FF6B6B', description: 'Performance improvements' },
                'type: security': { color: 'B60205', description: 'Security-related changes' },
                'type: breaking': { color: 'FF0000', description: 'Breaking changes that affect API compatibility' }
              };
              
              if (labelConfigs[label]) {
                try {
                  await github.rest.issues.getLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label
                  });
                } catch (error) {
                  if (error.status === 404) {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: label,
                      color: labelConfigs[label].color,
                      description: labelConfigs[label].description
                    });
                    console.log(`Created label: ${label}`);
                  }
                }
              }
            }
            
            // Add labels to PR
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd
              });
              console.log(`Added labels: ${labelsToAdd.join(', ')}`);
            }
            
            // Set outputs
            core.setOutput('detected_types', labelsToAdd.join(','));
            core.setOutput('is_breaking', detectedTypes.includes('type: breaking').toString());
            core.setOutput('is_feature', detectedTypes.includes('type: feature').toString());
            core.setOutput('is_bugfix', detectedTypes.includes('type: bugfix').toString());
            
            return {
              types: labelsToAdd,
              isBreaking: detectedTypes.includes('type: breaking'),
              totalChanges: additions + deletions,
              filesChanged: changedFiles.length
            };

      - name: ğŸš¨ Breaking change notification
        if: steps.analyze.outputs.is_breaking == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const warningComment = `ğŸš¨ **Breaking Change Detected**
            
            This PR appears to contain breaking changes that may affect API compatibility.
            
            Please ensure:
            - [ ] Breaking changes are documented in the PR description
            - [ ] Migration guide is provided if necessary  
            - [ ] Version bump strategy is considered
            - [ ] Stakeholders have been notified
            
            If this detection is incorrect, you can remove the \`type: breaking\` label manually.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: warningComment
            });

      - name: ğŸ“Š Type detection summary
        run: |
          echo "ğŸ” PR Type Detection Complete!"
          echo "ğŸ·ï¸ Detected types: ${{ steps.analyze.outputs.detected_types }}"
          echo "ğŸ’¥ Breaking change: ${{ steps.analyze.outputs.is_breaking }}"
          echo "âœ¨ Feature: ${{ steps.analyze.outputs.is_feature }}"
          echo "ğŸ› Bugfix: ${{ steps.analyze.outputs.is_bugfix }}"
